<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SiteScore AI</title>
  <link rel="stylesheet" href="styles.css" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
    defer
  ></script>
</head>
<body>
  <div class="app-shell">
    <header class="hero">
      <span class="hero-badge">Beta Preview</span>
      <h1>SiteScore AI</h1>
      <p class="hero-lede">Analizează potențialul unei locații în câteva secunde. Introdu adresa dorită și obține un scor clar bazat pe infrastructură, servicii și context urban.</p>
      <div class="hero-score">
        <span class="score-ring hero-ring"><span id="heroScore">–</span></span>
        <div class="hero-score-copy">
          <p class="hero-score-title">Ultimul scor generat</p>
          <p class="hero-score-meta" id="heroScoreMeta">Alege o locație pentru a vedea rezultatele.</p>
        </div>
      </div>
    </header>

    <main class="layout">
      <section class="panel panel--search">
        <div class="panel-header">
          <div>
            <h2>Locație analizată</h2>
            <p class="panel-subtitle">Tastează minimum 3 litere pentru sugestii instant</p>
          </div>
          <button type="button" id="exportPdf" class="ghost">Exportă PDF</button>
        </div>

        <form onsubmit="return false;" class="search-form">
          <label class="field field--full">
            <span class="field-label">Caută locație</span>
            <input id="location" type="search" autocomplete="off" placeholder="Ex: Piața Sfatului 1, Brașov" />
            <div id="suggestions" class="suggestions" aria-live="polite" hidden></div>
          </label>

          <input id="lat" type="hidden" value="45.657" />
          <input id="lon" type="hidden" value="25.601" />

          <label class="field">
            <span class="field-label">Rază analiză (m)</span>
            <input id="radius" type="number" step="100" value="1000" min="200" />
          </label>

          <div class="actions">
            <button type="button" id="go">Calculează scorul</button>
            <p class="selection-hint" id="selectionHint">Coordonate curente: 45.657, 25.601</p>
          </div>
        </form>
      </section>

      <section class="panel panel--insights">
        <div class="score-card">
          <div class="score-ring">
            <span id="overallScore">–</span>
          </div>
          <div class="score-copy">
            <p class="score-title">Scor general</p>
            <p class="score-meta" id="poiSummary">Selectează o locație pentru a începe.</p>
          </div>
        </div>

        <div class="radius-overview">
          <h3>Compară pe raze</h3>
          <ul class="radius-list" id="radiusBreakdown"></ul>
        </div>

        <div class="categories-block">
          <div class="categories-header">
            <h3>Categorii cheie</h3>
            <span class="caption">Sortate după scor</span>
          </div>
          <div class="categories" id="categoryList"></div>
        </div>
      </section>

      <section class="panel panel--map">
        <div class="panel-header">
          <div>
            <h2>Hartă locație</h2>
            <p class="panel-subtitle">Heatmap-ul va sosi în iterația următoare</p>
          </div>
        </div>
        <div id="map" role="presentation"></div>
      </section>

      <section class="panel panel--raw">
        <details class="inspector">
          <summary>JSON brut</summary>
          <pre id="out" aria-live="polite"></pre>
        </details>
      </section>
    </main>
  </div>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const API_BASE = 'http://127.0.0.1:8000';
      const INITIAL_COORDS = [45.657, 25.601];

      const map = L.map('map', { zoomControl: false }).setView(INITIAL_COORDS, 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map);
      const poiLayer = L.layerGroup().addTo(map);
      const marker = L.circleMarker(INITIAL_COORDS, {
        radius: 9,
        color: '#0a7aff',
        fillColor: '#0a7aff',
        fillOpacity: 0.75,
      }).addTo(poiLayer);

      const locationInput = document.getElementById('location');
      const suggestionsEl = document.getElementById('suggestions');
      const latInput = document.getElementById('lat');
      const lonInput = document.getElementById('lon');
      const radiusInput = document.getElementById('radius');
      const selectionHint = document.getElementById('selectionHint');
      const poiSummary = document.getElementById('poiSummary');
      const categoryList = document.getElementById('categoryList');
      const radiusBreakdown = document.getElementById('radiusBreakdown');
      const overallScore = document.getElementById('overallScore');
      const heroScore = document.getElementById('heroScore');
      const heroScoreMeta = document.getElementById('heroScoreMeta');
      const rawOutput = document.getElementById('out');
      const goButton = document.getElementById('go');
      let lastSelectedLabel = 'Brașov, România';
      let suggestionController = null;

      const formatScore = (score) => `${Number(score).toFixed(1)} / 100`;
      const formatCoord = (value) => Number(value).toFixed(5);

      function updateSelection(lat, lon, label) {
        latInput.value = lat.toFixed(6);
        lonInput.value = lon.toFixed(6);
        lastSelectedLabel = label || lastSelectedLabel;
        if (label) {
          locationInput.value = label;
        }
        selectionHint.textContent = `Coordonate curente: ${formatCoord(lat)}, ${formatCoord(lon)} — ${lastSelectedLabel}`;
        marker.setLatLng([lat, lon]);
        map.setView([lat, lon], 13);
      }

      function hideSuggestions() {
        suggestionsEl.hidden = true;
        suggestionsEl.innerHTML = '';
      }

      function renderSuggestions(items) {
        if (!items.length) {
          suggestionsEl.hidden = false;
          suggestionsEl.innerHTML = `<div class="empty">Nu am găsit sugestii pentru această căutare.</div>`;
          return;
        }
        suggestionsEl.hidden = false;
        suggestionsEl.innerHTML = '';
        items.forEach((item) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = item.formatted || item.display_name;
          btn.addEventListener('click', () => {
            locationInput.value = item.formatted || item.display_name;
            updateSelection(item.lat, item.lon, item.formatted || item.display_name);
            hideSuggestions();
            evaluateLocation();
          });
          suggestionsEl.appendChild(btn);
        });
      }

      async function fetchSuggestions(term) {
        const query = term.trim();
        if (query.length < 3) {
          hideSuggestions();
          return;
        }

        if (suggestionController) {
          suggestionController.abort();
        }
        suggestionController = new AbortController();
        const { signal } = suggestionController;

        suggestionsEl.hidden = false;
        suggestionsEl.innerHTML = `<div class="empty">Se caută locații...</div>`;
        try {
          const response = await fetch(`${API_BASE}/geocode/search?q=${encodeURIComponent(query)}&limit=5`, { signal });
          if (!response.ok) {
            throw new Error('Nu am putut obține sugestii.');
          }
          const data = await response.json();
          renderSuggestions(data);
        } catch (error) {
          if (error.name === 'AbortError') {
            return;
          }
          console.error('Eroare la autocomplete', error);
          suggestionsEl.hidden = false;
          suggestionsEl.innerHTML = `<div class="empty">${error.message || 'Eroare la încărcarea sugestiilor.'}</div>`;
        }
      }

      function renderRadiusSummary(summary) {
        radiusBreakdown.innerHTML = '';
        Object.entries(summary)
          .sort((a, b) => Number(a[0]) - Number(b[0]))
          .forEach(([radius, info]) => {
            const item = document.createElement('li');
            item.innerHTML = `
              <span class="radius-value">${radius} m</span>
              <span>${formatScore(info.overall_score)} · ${info.total_pois} POI</span>
            `;
            radiusBreakdown.appendChild(item);
          });
      }

      function renderCategories(categories) {
        categoryList.innerHTML = '';
        Object.entries(categories)
          .sort((a, b) => b[1].score - a[1].score)
          .forEach(([name, info]) => {
            const card = document.createElement('article');
            card.className = 'category-card';
            card.innerHTML = `
              <header>
                <p class="card-label">${name}</p>
                <p class="card-score">${formatScore(info.score)}</p>
              </header>
              <p class="card-meta">${info.count} puncte de interes</p>
              <p class="card-meta">Prag ${info.threshold}</p>
            `;
            categoryList.appendChild(card);
          });
      }

      async function evaluateLocation() {
        const lat = parseFloat(latInput.value);
        const lon = parseFloat(lonInput.value);
        const radius = parseInt(radiusInput.value, 10);

        if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
          poiSummary.dataset.state = 'error';
          poiSummary.textContent = 'Alege mai întâi o locație din listă.';
          return;
        }

        const params = new URLSearchParams({ lat, lon, radius_m: radius });
        overallScore.textContent = '–';
        heroScore.textContent = '–';
        heroScoreMeta.textContent = 'Alege o locație pentru a vedea rezultatele.';
        poiSummary.textContent = 'Se prelucrează...';
        poiSummary.dataset.state = 'loading';
        categoryList.innerHTML = '';
        radiusBreakdown.innerHTML = '';

        try {
          const response = await fetch(`${API_BASE}/scorecard?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`Eroare API (${response.status})`);
          }
          const payload = await response.json();
          poiSummary.dataset.state = 'ready';
          rawOutput.textContent = JSON.stringify(payload, null, 2);
          overallScore.textContent = formatScore(payload.summary.overall_score);
          heroScore.textContent = formatScore(payload.summary.overall_score);
          poiSummary.textContent = `${payload.summary.total_pois} POI în ${payload.radius_m}m (cache: ${payload.source.cache_hit ? 'da' : 'nu'})`;
          heroScoreMeta.textContent = `În ${payload.radius_m} m · ${payload.summary.total_pois} puncte de interes`;
          renderCategories(payload.categories);
          if (payload.radius_summary) {
            renderRadiusSummary(payload.radius_summary);
          }

          updateSelection(payload.coordinates.lat, payload.coordinates.lon, lastSelectedLabel);
        } catch (error) {
          console.error('Eroare la evaluare', error);
          poiSummary.dataset.state = 'error';
          poiSummary.textContent = error.message || 'Nu am putut obține datele.';
        }
      }

      locationInput.addEventListener('input', (event) => {
        fetchSuggestions(event.target.value);
      });

      locationInput.addEventListener('focus', () => {
        if (suggestionsEl.innerHTML.trim()) {
          suggestionsEl.hidden = false;
        }
      });

      document.addEventListener('click', (event) => {
        if (!suggestionsEl.contains(event.target) && event.target !== locationInput) {
          hideSuggestions();
        }
      });

      goButton.addEventListener('click', evaluateLocation);
      document.getElementById('exportPdf').addEventListener('click', () => {
        alert('Exportul PDF va fi disponibil în iterația următoare.');
      });

      updateSelection(INITIAL_COORDS[0], INITIAL_COORDS[1], lastSelectedLabel);
    });
  </script>
</body>
</html>
